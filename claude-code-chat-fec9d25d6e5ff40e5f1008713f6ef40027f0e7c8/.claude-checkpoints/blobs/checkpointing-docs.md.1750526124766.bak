# Checkpointing System Documentation

## Overview

Claude Code Chat implements a comprehensive checkpointing system that automatically tracks all file modifications made by Claude Code and provides users with the ability to revert changes through the UI. This system uses SQLite for metadata storage and patch files for change tracking.

## Architecture

### Core Components

1. **SQLite Database** (`metadata.db`)
   - Stores checkpoint metadata and relationships
   - Located at `.claude-checkpoints/metadata.db`
   - Manages session, message, and file change associations

2. **Patch Storage** (`blobs/`)
   - Stores unified diff patches for each change
   - Located at `.claude-checkpoints/blobs/`
   - Files named with checkpoint UUID + `.patch` extension

3. **Checkpoint Directory Structure**
   ```
   .claude-checkpoints/
   ├── metadata.db          # SQLite database
   └── blobs/               # Patch files
       ├── uuid-1.patch
       ├── uuid-2.patch
       └── backup-files/    # Automatic backups
   ```

## Database Schema

### Checkpoints Table

```sql
CREATE TABLE checkpoints (
  id TEXT PRIMARY KEY,           -- UUID for checkpoint
  session_id TEXT NOT NULL,      -- App conversation session
  message_id TEXT NOT NULL,      -- Message that triggered change
  file_path TEXT NOT NULL,       -- Absolute path to modified file
  ts DATETIME DEFAULT CURRENT_TIMESTAMP,
  patch_path TEXT,              -- Relative path to patch file
  full_snapshot INTEGER DEFAULT 0,  -- 1 for new files, 0 for edits
  old_content TEXT,             -- Original file content
  new_content TEXT,             -- New file content
  tool_type TEXT                -- Edit, MultiEdit, or Write
);
```

## Automatic Checkpoint Creation

### Trigger Conditions

Checkpoints are automatically created when Claude Code uses these tools:

1. **Edit Tool**: Single file edits with find/replace operations
2. **MultiEdit Tool**: Multiple edits within a single file
3. **Write Tool**: File creation or complete file overwrites

### Creation Process

1. **Tool Detection**: Monitor Claude's streaming output for tool_use blocks
2. **Pre-Change Capture**: Read current file content before modification
3. **Patch Generation**: Create unified diff between old and new content
4. **Atomic Storage**: Write patch to temp file, then rename for atomicity
5. **Database Record**: Insert checkpoint metadata with all relationships

```javascript
// Example checkpoint creation flow
const checkpoint = {
  id: uuidv4(),
  session_id: sessionId,
  message_id: assistantMessageId,
  file_path: '/path/to/file.js',
  old_content: 'function old() {...}',
  new_content: 'function new() {...}',
  tool_type: 'Edit'
};
```

## File Change Tracking

### MultiEdit Handling

MultiEdit tools are decomposed into individual Edit operations:

```javascript
// MultiEdit with 3 edits becomes 3 separate checkpoints
{
  file_path: "app.js",
  edits: [
    { old_string: "old1", new_string: "new1" },
    { old_string: "old2", new_string: "new2" },
    { old_string: "old3", new_string: "new3" }
  ]
}
// → Creates 3 checkpoints linked to same message
```

### Write Tool Handling

Write operations handle both file creation and overwrites:

- **New Files**: `full_snapshot = 1`, `old_content = ""`
- **Overwrites**: `full_snapshot = 0`, `old_content = <existing content>`

## Revert Functionality

### Main Process (main.js)

```javascript
// Get all checkpoints from a message forward
async function getCheckpointsToRevert(sessionId, messageId) {
  const stmt = checkpointDb.prepare(`
    SELECT * FROM checkpoints
    WHERE session_id = ? AND message_id >= ?
    ORDER BY ts DESC
  `);
  return stmt.all([sessionId, messageId]);
}

// Revert files to their pre-change state
async function revertToCheckpoint(sessionId, messageId) {
  const checkpoints = await getCheckpointsToRevert(sessionId, messageId);
  const revertedFiles = [];
  
  // Group by file path to handle multiple changes
  const fileGroups = {};
  checkpoints.forEach(checkpoint => {
    if (!fileGroups[checkpoint.file_path]) {
      fileGroups[checkpoint.file_path] = [];
    }
    fileGroups[checkpoint.file_path].push(checkpoint);
  });
  
  // Revert each file to its original state
  for (const [filePath, checkpointList] of Object.entries(fileGroups)) {
    const latestCheckpoint = checkpointList[0];
    
    if (latestCheckpoint.full_snapshot && latestCheckpoint.old_content === '') {
      // Delete newly created file
      await fs.unlink(filePath);
    } else {
      // Restore original content
      await fs.writeFile(filePath, latestCheckpoint.old_content);
    }
    
    revertedFiles.push(filePath);
  }
  
  return revertedFiles;
}
```

### IPC Communication

The main process exposes these checkpoint-related IPC handlers:

```javascript
// Revert to a specific message point
ipcMain.handle('revert-to-message', async (event, sessionId, messageId) => {
  const revertedFiles = await revertToCheckpoint(sessionId, messageId);
  
  // Also truncate conversation history
  const session = sessions.get(sessionId);
  const messageIndex = session.messages.findIndex(m => m.id === messageId);
  session.messages = session.messages.slice(0, messageIndex + 1);
  
  return { success: true, revertedFiles };
});

// Check if a message has associated file changes
ipcMain.handle('has-file-changes', async (event, sessionId, messageId) => {
  const checkpoints = await getCheckpointsToRevert(sessionId, messageId);
  return checkpoints.length > 0;
});

// Get detailed checkpoint information
ipcMain.handle('get-message-checkpoints', async (event, sessionId, messageId) => {
  return await getCheckpointsToRevert(sessionId, messageId);
});
```

## Frontend Integration

### UI Components

The renderer process provides user interfaces for checkpoint management:

#### Message-Level Revert Buttons

```javascript
// Show revert option for messages with file changes
async function checkForFileChanges(sessionId, messageId) {
  const hasChanges = await window.electronAPI.hasFileChanges(sessionId, messageId);
  
  if (hasChanges) {
    showRevertButton(messageId);
  }
}

// Handle revert action
async function revertToMessage(sessionId, messageId) {
  const result = await window.electronAPI.revertToMessage(sessionId, messageId);
  
  if (result.success) {
    showNotification(`Reverted ${result.revertedFiles.length} files`);
    refreshConversation(sessionId);
  }
}
```

#### Visual Indicators

- **File Change Badges**: Messages with file modifications show visual indicators
- **Revert Buttons**: Appear on messages that have associated checkpoints
- **Status Notifications**: Confirm successful reverts with file counts

### Preload Bridge

The preload script exposes checkpoint functionality to the renderer:

```javascript
// preload.js
window.electronAPI = {
  // Checkpoint operations
  revertToMessage: (sessionId, messageId) => 
    ipcRenderer.invoke('revert-to-message', sessionId, messageId),
  
  hasFileChanges: (sessionId, messageId) => 
    ipcRenderer.invoke('has-file-changes', sessionId, messageId),
  
  getMessageCheckpoints: (sessionId, messageId) => 
    ipcRenderer.invoke('get-message-checkpoints', sessionId, messageId)
};
```

## Safety Features

### Backup Creation

Before reverting files, the system creates automatic backups:

```javascript
// Create backup before reverting
const backupPath = path.join(
  checkpointBlobsDir, 
  path.basename(filePath) + '.' + Date.now() + '.bak'
);
await fs.copyFile(filePath, backupPath);
```

### Atomic Operations

- **Patch Writing**: Use temp files + rename for atomic writes
- **Database Updates**: SQLite transactions ensure consistency
- **Session Updates**: Conversation history changes are atomic

### Error Handling

- **Database Failures**: Graceful degradation if SQLite unavailable
- **File System Errors**: Detailed logging and user notifications
- **Process Interruption**: Recovery mechanisms for incomplete operations

## Limitations and Considerations

### Current Limitations

1. **No Cross-Session Tracking**: Checkpoints are scoped to individual conversations
2. **No Partial Reverts**: Must revert entire message point, not individual files
3. **Storage Growth**: Patch files accumulate over time (no automatic cleanup)
4. **Binary Files**: Only text files are properly handled by diff system

### Performance Considerations

- **Database Size**: Scales with number of file changes
- **Patch Storage**: Efficient for text files, less so for large files
- **Memory Usage**: Checkpoints kept in memory during active sessions

### Future Enhancements

1. **Selective File Revert**: Allow reverting individual files from a message
2. **Checkpoint Cleanup**: Automatic pruning of old checkpoints
3. **Binary File Support**: Proper handling of non-text files
4. **Cross-Session Tracking**: Global change history across conversations
5. **Visual Diff Viewer**: Show exact changes before reverting

## Debugging and Troubleshooting

### Common Issues

1. **Database Initialization Failures**
   - Check `.claude-checkpoints` directory permissions
   - Verify SQLite3 installation
   - Review main process logs

2. **Missing Checkpoints**
   - Confirm tool detection is working
   - Check for streaming parsing errors
   - Verify database writes are completing

3. **Revert Failures**
   - Ensure target files exist and are writable
   - Check for conflicting file locks
   - Verify checkpoint data integrity

### Logging

Enable verbose logging to debug checkpoint issues:

```javascript
// In main.js
console.log('Checkpoint created:', checkpointId, 'for', file_path);
console.log('Detected file modification tool:', block.name);
console.log('Reverting session', sessionId, 'to message', messageId);
```

### Manual Database Inspection

```bash
# Open checkpoint database
sqlite3 .claude-checkpoints/metadata.db

# View all checkpoints
SELECT * FROM checkpoints ORDER BY ts DESC;

# Check specific session
SELECT * FROM checkpoints WHERE session_id = 'session-uuid';

# Count checkpoints by tool type
SELECT tool_type, COUNT(*) FROM checkpoints GROUP BY tool_type;
```

This checkpointing system provides robust change tracking and revert capabilities, giving users confidence to experiment with Claude Code while maintaining the ability to undo unwanted modifications.